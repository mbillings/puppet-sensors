#!/bin/bash
#
# Purpose: Initialize ipmi and create Zabbix items for the host
#
# Comments: As of 26 June 2012, IPMI identifiers are non-unique and non-consistent across platforms.
# 	    Therefore, an ipmi template(s) to rule them all is not feasible.
# 	    In addition, the Zabbix IPMI interface requires a template to work. 
# 	    Thus, until a grand unified template is created or a newer IPMItools returns unique and consistent IDs,
# 	    we are forced to slightly edit what IPMI returns to create unique Zabbix items.
#
# 	    Due to curl formatting, quotation marks must be delimited so that the delimits will be read at
#	    execution time and interpreted as quotes. 
#	    For examples and formatting, see http://www.zabbix.com/documentation/1.8/api 
#	    or ssh://vcs.missouri.edu/var/git/csglinux.git/docs/zabbix_curl_api

# one arg (--init) is supported, see if it was used
case $1 in
--init)
	initialize=yes
;;
*)	initialize=no
;;
esac


#############################
## User-editable variables ##
#############################
key="csg.sensors_ipmi_"
key_last_sel=$key"last_sel"
ipmistatus=$key"daemon_status"
LSMOD="/sbin/lsmod"

zs=<%= scope.lookupvar('zabbix-agent::which_zsender') %>
zserver=<%= scope.lookupvar('zabbix-agent::zabbix_server') %>
zport=10051
thisserver=<%= fqdn %>
zapi="https://zabbix.missouri.edu/zabbix/api_jsonrpc.php"
zauth="91240fb8d61542580a3d2e7b00920b3c"
#############################


#######################################################################################
## Check if ipmi modules are loaded. If none detected, try to load necessary modules ##
#######################################################################################
modules=`$LSMOD | grep -i ^ipmi | wc -l`
if [ "$modules" -eq 0 ] 
then
	/sbin/modprobe ipmi_devintf

        if [ -c /dev/ipmi0 ]
	then rm -f /dev/ipmi0
	fi

	/bin/mknod /dev/ipmi0 c `cat /proc/devices | awk '/ipmidev/{print $1}'` 0

	IPMI_DRIVERS="ipmi_si ipmi_si_drv ipmi_kcs_drv"
	for driver in $IPMI_DRIVERS; 
	do
	  found=$( find /lib/modules/`uname -r`/kernel/drivers/char/ipmi | grep $driver | grep -v "^$" | wc -l 2>/dev/null )
	  if [ "$found" -ne 0 ] 
	  then
	    #Here are specific memory locations for Supermicro AOC-type IPMI cards
	    /sbin/modprobe $driver type=kcs ports=0xca8 regspacings=4
	    break
	  fi
	done

	modules=`$LSMOD | grep -i ^ipmi | wc -l`
	if [ "$modules" -eq 0 ]	
	then
		# if no modules are available, alert zabbix
		$zs -vv -z $zserver -p $zport -s $thisserver -k $ipmistatus -o NoModulesAvailable 1>/dev/null 2>/dev/null
		exit 0
	fi
fi
#######################################################################################




#############################################################
## Format host id, app id, and security event log requests ##
#############################################################
hostdata=\{\"jsonrpc\":\"2.0\",\"method\":\"host.get\",\"params\":\{\"output\":\"extend\",\"filter\":\{\"host\":\[\"$thisserver\"\]\}\},\"auth\":\"$zauth\",\"id\":\"2\"\}

# get host id from zabbix
hostid=$( curl -i -X POST -H 'Content-Type:application/json' -d $hostdata $zapi | tr ',' '\n' | grep \"hostid | tr '\"' '\n' | grep [0-9] )

appid=\{\"jsonrpc\":\"2.0\",\"method\":\"application.get\",\"params\":\{\"search\":\{\"name\":\"Sensors\"\},\"hostids\":\"$hostid\",\"output\":\"extend\",\"expandData\":1,\"limit\":1\},\"auth\":\"$zauth\",\"id\":2\}

# get sensors app id from zabbix
appid_exists=$( curl -i -X POST -H 'Content-Type:application/json' -d $appid $zapi | grep $thisserver | tr ',' '\n' | grep \"applicationid | tr '\"' '\n' | grep [0-9] )

# if the application does not exist, create it and set the create items variable
if [ -z $appid_exists ]
then
	# create Sensors application for host's classification
	appdata=\{\"jsonrpc\":\"2.0\",\"method\":\"application.create\",\"params\":\[\{\"name\":\"Sensors\",\"hostid\":\"$hostid\"\}\],\"auth\":\"$zauth\",\"id\":2\}
	appid=$( curl -i -X POST -H 'Content-Type:application/json' -d $appdata $zapi | tr ',' '\n' | grep \"applicationid | tr '\"' '\n' | grep [0-9] )

	# set the flag to initialize items
	initialize=yes
fi

# ipmi security event log key
if [ "$initialize" == "yes" ]
then
	# see if the ipmi sel key exists or not
	existsdata=\{\"jsonrpc\":\"2.0\",\"method\":\"item.exists\",\"params\":\{\"host\":\"$thisserver\",\"key_\":\"$keyname\"\},\"auth\":\"91240fb8d61542580a3d2e7b00920b3c\",\"id\":\"2\"\} 
        exists=$( curl -i -X POST -H 'Content-Type:application/json' -d $existsdata $zapi | tr ',' '\n' | grep result | cut -d: -f2 )

	# if it does not exist, then create it
	if [ "$exists" == "false" ]
	then
		# create ipmi security event log key
		itemdata=\{\"jsonrpc\":\"2.0\",\"method\":\"item.create\",\"params\":\{\"description\":\"$key_last_sel\",\"key_\":\"$key_last_sel\",\"type\":\"2\",\"value_type\":\"4\",\"history\":\"30\",\"trends\":\"365\",\"delay\":\"120\",\"hostid\":\"$hostid\",\"applications\":\[\"$appid\"\]\},\"auth\":\"$zauth\",\"id\":\"2\"\}
    		curl -i -X POST -H 'Content-Type:application/json' -d $itemdata $zapi
	fi
fi	

# send the last line of the sel to zabbix
$zs -vv -z $zserver -p $zport -s $thisserver -k $key_last_sel -o "$( /usr/bin/ipmitool sel list | tail -1 | sed 's/^[ \t]*//' | sed 's/[ \t]*$//g' | sed s/\|//g | sed s/\ /_/g | sed s/\\//_/g | sed s/\:/_/g | sed s/\#//g )" 1>/dev/null 2>/dev/null
###################################################################




#############################################################################
## Ipmitool only returns a few entities, and of those, we only care about: ##
## 3=CPU, 7=System Board, 8=Memory, 10=Power, 26=Disk Drive Bay            ##
#############################################################################
for i in 3 7 8 10 26 
do 
        IPMInum=( $( /usr/bin/ipmitool sdr entity $( echo $i ) | egrep -iv "\ $|Disabled|State\ Deasserted|No\ Reading|Error|Unknown" | tr [:upper:] [:lower:] | sed s/-//g | tr '\n' ';' ) ) 
 
        IPMIcount=`echo "${IPMInum[@]}" | tr ';' '\n' | grep -v "^$" | wc -l` 
 
        # set counter to create unique id names (IPMI does not always have unique ids, so we must make them unique)
        counter=0 
 
	# get the values of items
        for (( j=1; j<=$IPMIcount; j++ )) 
        do	# move sequentially top to bottom 
	        IPMIval=`echo "${IPMInum[@]}" | tr ';' '\n' | head -"$j" | tail -1` 
 
                if [ `echo $IPMIval | egrep "3\.[0-9]|8\.[0-9]|10\.[0-9]" | wc -l` -ge 1 ] 
                then 
                        # get the number of the device 
                        qualifier=`echo $IPMIval | awk -F \| '{print $4}' | awk -F \. '{print $2}' | sed 's/[ \t]*$//g'` 
			
			# formatting, semantics
                        if [ `echo $IPMIval | awk -F \| '{print $4}' | egrep -i "3\.[0-9]" | wc -l` -ge 1 ] 
                        then    qualifier=cpu"$qualifier"_ 
                        else    if [ `echo $IPMIval | awk -F \| '{print $4}' | grep -i "8\.[0-9]" | wc -l` -ge 1 ] 
                                then    qualifier=dimm"$counter"_ 
                                        counter=$(( $counter + 1 )) 
                                else    qualifier=ps"$qualifier"_ 
                                fi 
                        fi 
                else    if [ `echo $IPMIval | grep "7\.[0-9]" | awk -F \| '{print $1}' | grep -i BMC | wc -l` -ge 1 ] 
                        then    qualifier=bmc"$counter"_ 
                                counter=$(( $counter + 1 )) 
                        else    if [ `echo $IPMIval | grep "26\.[0-9]" | wc -l` -ge 1 ] 
                                then    qualifier=disk"$counter"_ 
                                else    qualifier="" 
                                fi 
                        fi 
                fi 
 
		# get key suffix
                keyname=$key"$qualifier""$( echo $IPMIval | awk -F \| '{print $1}' | sed 's/[ \t]*$//g' | sed s/\ /_/g )"
		# determine what unit value zabbix should use for this key
		if [ $( echo $IPMIval | awk -F \| '{print $5}' | awk '{print $1}' | sed s/\-// | grep ^[0-9] | wc -l ) -eq 1 ]
		then 	# numeric (float)
			units=$( echo $IPMIval | awk -F \| '{print $5}' | cut -d' ' -f2 --complement | sed 's/^[ \t]*//' | sed s/\ /_/g | sed 's/[ \t]*//' | tr [:upper:] [:lower:] )
			valuetype=0
			keyval=$( echo $IPMIval | awk -F \| '{print $5}' | awk '{print $1}' | sed s/\-// )
		else 	# text
			valuetype=4
			keyval=$( echo $IPMIval | awk -F \| '{print $5}' | sed 's/[ \t]*$//g' | sed 's/^[ \t]*//' | sed s/\ /_/g ) 
		fi

		#### create items ####
		if [ "$initialize" == "yes" ]
		then
        		# check if item exists
			existsdata=\{\"jsonrpc\":\"2.0\",\"method\":\"item.exists\",\"params\":\{\"host\":\"$thisserver\",\"key_\":\"$keyname\"\},\"auth\":\"91240fb8d61542580a3d2e7b00920b3c\",\"id\":\"2\"\} 
			exists=$( curl -i -X POST -H 'Content-Type:application/json' -d $existsdata $zapi | tr ',' '\n' | grep result | cut -d: -f2 )
		
			# if item does not exist, create it
			if [ "$exists" == "false" ]
			then
				# if the item is a number, specify units. Otherwise it is text, so no units necessary
				if [ $valuetype -eq 0 ]
				then 
					itemdata=\{\"jsonrpc\":\"2.0\",\"method\":\"item.create\",\"params\":\{\"description\":\"$keyname\",\"key_\":\"$keyname\",\"type\":\"2\",\"value_type\":\"$valuetype\",\"units\":\"$units\",\"history\":\"30\",\"trends\":\"365\",\"delay\":\"120\",\"hostid\":\"$hostid\",\"applications\":\[\"$appid\"\]\},\"auth\":\"$zauth\",\"id\":\"2\"\}
				else 
					itemdata=\{\"jsonrpc\":\"2.0\",\"method\":\"item.create\",\"params\":\{\"description\":\"$keyname\",\"key_\":\"$keyname\",\"type\":\"2\",\"value_type\":\"$valuetype\",\"history\":\"30\",\"trends\":\"365\",\"delay\":\"120\",\"hostid\":\"$hostid\",\"applications\":\[\"$appid\"\]\},\"auth\":\"$zauth\",\"id\":\"2\"\}
				fi
			fi
			curl -i -X POST -H 'Content-Type:application/json' -d $itemdata $zapi
		fi
		#### /create items ####
		

		# send the item's value to zabbix
		$zs -vv -z $zserver -p $zport -s $thisserver -k $keyname -o "$keyval" 1>/dev/null 2>/dev/null
        done 
done 
#############################################################################
